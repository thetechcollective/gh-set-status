#!/usr/bin/env bash

USAGE=$(cat <<'EOF'
  gh set-status {state} {description}
  gh set-status {state} {description} {context}
  gh set-status {state} {description} {context} {target_url}
  gh set-status inherit [ref]

GitHub CLI extension that sets a commit status using the GitHub CLI. 

NOTE:
  Specifically designed to run in a GitHub Actions workflow context.
  Environment variables $GITHUB_REPOSITORY, $GITHUB_SHA, $GITHUB_ACTION, 
  $GITHUB_RUN_ID and $GITHUB_SERVER_URL must be defined manually when 
  running/testing outside of GitHub Actions.

Arguments:
  state        The status state, valid values are [success|error|failure|pending]
               (Required as first argument)
  description  A description of the status (Required as second argument)
  context      The status context (Optional third argument). if not given will be 
               set to the value of $GITHUB_ACTION. The keyword 'default' is allowed 
               too.
  target_url   The target URL for the status
               Optional fourth argument. if not given will be set to the the url
               value to the current workflow run. The keyword 'default' is allowed
               too.

Inheritance:
  inherit [ref]
               Copies the latest statuses (by context) from {ref} and applies them
               to the current commit ($GITHUB_SHA). If a copied status has no
               target_url, it defaults to the current workflow run URL.
               If {ref} is omitted, the tool attempts to derive it from the
               current commit message ($GITHUB_SHA) by taking the first line that
               matches '<sha>: ...' from the squeezed commit list.

When used from a GitHub Workflow...
Assuming 

  runs-on: ubuntu-latest

Install:

Install it as a GitHub CLI extension:
gh extension install thetechcollective/gh-set-status

Create a step in your GitHub Actions workflow to install the `gh-set-status` 
extension:

    - name: Install gh dependencies
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh extension install thetechcollective/gh-set-status --pin stable

It requires statuses:write permissions - like this:

permissions:
  statuses: write

Examples:

gh set-status pending "Spelling checks in progress"
gh set-status pending "Spelling checks in progress" linting
gh set-status pending "Spelling checks in progress" linting https://example.com
gh set-status pending "Spelling checks in progress" default default

gh set-status inherit                 # derive ref from commit message
gh set-status inherit feature-branch

gh set-status inherit abc1234

See plenty of more examples in the workflows in https://github.com/thetechcollective/workflows

EOF
)

# --- Helpers ---
check_env_or_die() {
  if [[ -z "$GITHUB_REPOSITORY" || -z "$GITHUB_SHA" || -z "$GITHUB_ACTION" || -z "$GITHUB_RUN_ID" || -z "$GITHUB_SERVER_URL" ]]; then
    echo "❌ Not running in a GitHub Actions workflow context."
    echo "Environment variables GITHUB_REPOSITORY, GITHUB_SHA, GITHUB_ACTION, GITHUB_RUN_ID, and GITHUB_SERVER_URL are not set."
    echo "Usage:"
    echo
    echo "$USAGE"
    exit 1
  fi
}

# New helper: derive a ref from the current commit message format '<sha>: ...'
derive_ref_from_commit_message() {
  local MSG REF
  # Prefer local git (faster, no network). Requires checkout.
  if git rev-parse --git-dir >/dev/null 2>&1; then
    MSG=$(git log -1 --format=%B "$GITHUB_SHA" 2>/dev/null || true)
  fi
  # Fallback to GitHub API only if local git didn't provide a message
  if [[ -z "$MSG" ]]; then
    MSG=$(gh api \
      -H "Accept: application/vnd.github+json" \
      -H "X-GitHub-Api-Version: 2022-11-28" \
      "/repos/$GITHUB_REPOSITORY/commits/$GITHUB_SHA" \
      --jq '.commit.message' 2>/dev/null) || true
  fi
  [[ -z "$MSG" ]] && return 1
  # Extract the first '<sha>:' or '<sha> ' prefix from the squeezed list efficiently with sed
  REF=$(printf '%s\n' "$MSG" | sed -nE 's/^([0-9a-fA-F]{7,40})[: ].*/\1/p' | head -n1)
  [[ -z "$REF" ]] && return 1
  printf '%s\n' "$REF"
}

inherit_statuses() {
  local SRC_REF="$1"
  if [[ -z "$SRC_REF" ]]; then
    echo "ℹ️ No ref provided, attempting to derive from commit message of $GITHUB_SHA"
    SRC_REF=$(derive_ref_from_commit_message) || true
    if [[ -z "$SRC_REF" ]]; then
      echo "❌ Could not derive {ref} from commit message. Provide a ref explicitly."
      echo
      echo "Usage:"
      echo "$USAGE"
      exit 1
    fi
    echo "ℹ️ Derived ref: $SRC_REF"
  fi

  echo "####### Inheriting commit statuses ########"
  echo "  from ref:     '$SRC_REF'"
  echo "  to commit:    '$GITHUB_SHA'"
  echo "  repository:   '$GITHUB_REPOSITORY'"

  echo "Fetching statuses from ref \`$SRC_REF\`..."                   >> $GITHUB_STEP_SUMMARY
  echo "Read from the commit message on this commit  \`$GITHUB_SHA\`" >> $GITHUB_STEP_SUMMARY

  # Check there are statuses to inherit
  local STAT_COUNT
  local api_result
  set +e
  api_result=$(gh api \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$GITHUB_REPOSITORY/commits/$SRC_REF/status" \
    --jq '.statuses | length' 2>&1)
  local exit_code=$?
  set -e

  echo $api_result

  if [[ $exit_code -ne 0 ]] || [[ -z "$api_result" ]]; then
    echo "❌ Failed to fetch statuses from ref '$SRC_REF'." >> $GITHUB_STEP_SUMMARY
    echo '```' >> $GITHUB_STEP_SUMMARY
    echo "API result: $api_result" >> $GITHUB_STEP_SUMMARY
    echo '```' >> $GITHUB_STEP_SUMMARY
    exit 1
  fi
  if (( api_result == 0 )); then
    echo "ℹ️ No statuses found on ref '$SRC_REF'. Nothing to inherit."
    return 0
  fi

  # Iterate latest statuses per context (as provided by the combined status endpoint)
  # Track if all inherited statuses are 'success'
  local ALL_SUCCESS=true
  declare -A SEEN
  while IFS=$'\t' read -r STATE DESCRIPTION CONTEXT TARGET_URL; do
    [[ -z "$CONTEXT" ]] && continue
    if [[ -n "${SEEN[$CONTEXT]}" ]]; then
      continue
    fi
    SEEN[$CONTEXT]=1

    # Check if this status is not 'success'
    if [[ "$STATE" != "success" ]]; then
      ALL_SUCCESS=false
      echo "  ⚠️ $CONTEXT: $STATE" >&2
    fi

    local URL="$TARGET_URL"
    if [[ -z "$URL" ]]; then
      URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
    fi

    echo "  inheriting: context='$CONTEXT' state='$STATE'"
    {
      set -x
      gh api \
        --method POST \
        -H "Accept: application/vnd.github+json" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        "/repos/$GITHUB_REPOSITORY/statuses/$GITHUB_SHA" \
        -f "state=$STATE" \
        -f "target_url=$URL" \
        -f "description=$DESCRIPTION" \
        -f "context=$CONTEXT"
      set +x
    } 2>&1
  done < <(gh api \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$GITHUB_REPOSITORY/commits/$SRC_REF/status" \
    --jq '.statuses[] | [ .state, (.description // ""), .context, (.target_url // "") ] | @tsv')

  # Return appropriate exit code based on inherited statuses
  if [[ "$ALL_SUCCESS" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

set_status_cmd() {
  local STATE="$1"
  local DESCRIPTION="$2"
  local CONTEXT="$3"
  local TARGET_URL="$4"

  # Validate required
  if [[ -z "$STATE" || -z "$DESCRIPTION" ]]; then
    echo "❌ Required arguments are not given."
    echo
    echo "Usage:"
    echo "$USAGE"
    exit 1
  fi

  # Defaults
  if [[ -z "$CONTEXT" || "$CONTEXT" == "default" ]]; then
    CONTEXT="$GITHUB_ACTION"
  fi
  if [[ -z "$TARGET_URL" || "$TARGET_URL" == "default" ]]; then
    TARGET_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
  fi

  echo "####### Setting the commit status ########"
  echo "  state:       '$STATE'"
  echo "  description: '$DESCRIPTION'"
  echo "  context:     '$CONTEXT'"
  echo "  url:         '$TARGET_URL'"

  {
    set -x
    gh api \
      --method POST \
      -H "Accept: application/vnd.github+json" \
      -H "X-GitHub-Api-Version: 2022-11-28" \
      "/repos/$GITHUB_REPOSITORY/statuses/$GITHUB_SHA" \
      -f "state=$STATE" \
      -f "target_url=$TARGET_URL" \
      -f "description=$DESCRIPTION" \
      -f "context=$CONTEXT"
    set +x
  } 2>&1
}

# --- Main ---
CMD="$1"; shift || true
check_env_or_die
case "$CMD" in
  inherit)
    inherit_statuses "$1"
    exit $?
    ;;
  *)
    # In "set" mode, the first arg is actually the state
    STATE="$CMD"
    set_status_cmd "$STATE" "$1" "$2" "$3"
    ;;
esac
